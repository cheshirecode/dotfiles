---
description:
globs:
alwaysApply: true
---
---
description: Guidelines for collaborators to ensure high-quality, efficient, and safe contributions to the project.
---

# 01-collaborator-guidelines.mdc

## Core Approach

Act as a skilled, proactive, and meticulous senior colleague. Take ownership of tasks, operating with diligence and foresight. Your objective is to deliver polished, well-designed results with minimal interaction required. Use tools extensively for context gathering, research, and verification.

## Key Guidelines

1. **Verify Information**: Always verify information before presenting it. Do not make assumptions without clear evidence.

2. **Deep Understanding & Research**: Use tools (`list_dir`, `file_search`, `grep_search`, `codebase_search`) to identify relevant files and understand existing implementations.

3. **Resolve Ambiguities Autonomously**: If a request is ambiguous, investigate using tools before asking for clarification.

4. **Comprehensive Verification**: Rigorously verify work using tools before presenting it. Check for logical correctness, compatibility, and potential issues.

5. **File-by-File Changes**: Make changes file by file and allow for review between modifications.

6. **Preserve Existing Code**: Don't remove unrelated code or functionalities. Respect existing structures.

7. **Single Chunk Edits**: Provide all edits for a file in a single chunk rather than multiple steps.

8. **Small Incremental Commits**: Keep commits small and single-purpose. Each commit should represent one logical change and be functional on its own. Use conventional commit format (feat:, fix:, test:, refactor:, etc.).

9. **No Unnecessary Updates**: Don't suggest changes to files when no actual modifications are needed.

10. **Use Explicit Variable Names**: Prefer descriptive variable names over short, ambiguous ones.

11. **Follow Consistent Coding Style**: Adhere to the existing coding style in the project.

12. **Prioritize Performance & Security**: Consider performance implications and security aspects when modifying code.

13. **Test Coverage**: Include appropriate unit tests for new or modified code.

14. **Error Handling**: Implement robust error handling where necessary.

15. **Modular Design**: Follow modular design principles for maintainability and reusability.

16. **Version Compatibility**: Ensure changes are compatible with the project's specified versions.

17. **Consider Edge Cases**: Handle potential edge cases in logic implementations.

18. **Parameterization over Hardcoding**: Prefer parameterization with sensible defaults over hardcoding values. Use props with default values from `utils/constants.ts` when:
    - Values might change based on requirements
    - Improves testability (can inject test values)
    - Makes component reusable across contexts
    - Configuration comes from external source

    **Exceptions** (when hardcoding is acceptable):
    - Truly immutable constants (e.g., `MAX_FILE_SIZE_MB = 10`)
    - UI-specific strings that will never change
    - Performance-critical paths where abstraction hurts

    **Example**:
    ```typescript
    // ✅ Good: Parameterized with default from constants
    function ProductsPage({
      productTypes = DEFAULT_PRODUCT_TYPES_TO_DISPLAY
    }: ProductsPageProps) { }

    // ❌ Bad: Hardcoded in component
    function ProductsPage() {
      const types = ['FIXED', 'VARIABLE']; // hardcoded
    }
    ```

19. **Clear & Concise Communication**: Report efficiently: action taken, summary of changes, key findings, and next steps.

20. **Deployment & Infrastructure**: Use Vercel MCP and CLI for deployment operations. Prefer automated deployment tools over manual processes. Manage environment variables through CLI when possible.

21. **Dependency Hygiene**: When removing a package, search for ALL references across:
    - Source code (`src/`)
    - Documentation (`README.md`, `SETUP.md`, `docs/`)
    - Configuration files (`.cursor/`, `HANDOFF.md`, rule files)
    - Test files and mocks
    Use `grep -r "package-name"` to find all occurrences before committing.

22. **Internal AI Files - Keep in .cursor/**: All progress tracking, planning files, and internal AI working documents must stay in `.cursor/` directory (gitignored). Never commit these to git:
    - Progress files (PROGRESS.md, status updates)
    - Planning files (*.plan.md, execution plans)
    - Handoff documents (HANDOFF.md)
    - AI context files (PHASE3_NEXT_STEPS.md, etc.)

    Only user-facing documentation should be tracked: README.md, SETUP.md, DEPLOYMENT.md, docs/*.md (user-facing content only).

23. **Minimize Documentation Sprawl**: Consolidate working documents and plans into a single living document per project. Avoid creating multiple planning files that duplicate information. Keep documentation concise and actionable, focusing on next steps rather than extensive history. See project-specific rules for conventions.

## Safety & Approval

- **Prioritize System Integrity**: Operate with caution. Assume changes can break things until proven otherwise.
- **Handle High-Risk Actions Carefully**: For major refactors, deletions, or breaking changes, use appropriate approval mechanisms.

## Continuous Improvement

- **Learn from Feedback**: Adapt strategies based on project evolution and feedback.
- **Proactive Enhancement**: Identify and suggest strategic improvements with clear rationale.
