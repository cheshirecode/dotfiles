---
description: React TypeScript development guide - strict typing, atomic commits, architecture, testing, and project-specific tech decisions
---

---
title: React TypeScript Development Guide
category: development
tags: [react, typescript, vite, testing, performance]
last_updated: 2025-10-17
---

# React TypeScript Development Guide

> Comprehensive guide for React + TypeScript development with Vite, including strict typing, performance optimization, safe vendor chunking, and project-specific tech decisions.

## Table of Contents

1. [TypeScript Best Practices](#typescript-best-practices)
2. [React Best Practices](#react-best-practices)
3. [Project-Specific Tech Stack](#project-specific-tech-stack)
4. [Forms & Validation](#forms--validation)
5. [Error Handling & UX](#error-handling--ux)
6. [Project Structure](#project-structure)
7. [Git & Commits](#atomic-commits--git)
8. [Pre-commit Automation](#pre-commit-automation)
9. [Performance & Bundle Size](#performance--bundle-size)
10. [Accessibility](#accessibility)
11. [Environment Variables](#environment-variables)
12. [Deployment](#deployment)
13. [Documentation](#documentation)
14. [Quality Checklist](#quality-checklist)
15. [Anti-Patterns](#anti-patterns)
16. [Quick Reference](#quick-reference)

---

## TypeScript Best Practices

### Strict Mode Configuration
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

### Type Preferences
- **Interfaces** for public shapes (objects, component props)
- **Types** for unions, mapped types, utilities
- **Never use `any`** - use `unknown` with type guards
- **Discriminated unions** for state machines and API variants

### Component Patterns
```typescript
// ✅ GOOD: No React.FC, explicit return type, explicit props
interface ButtonProps {
  children: React.ReactNode;
  onClick: (e: React.MouseEvent<HTMLButtonElement>) => void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary' | 'ghost';
}

export function Button({
  children,
  onClick,
  disabled = false,
  variant = 'primary'
}: ButtonProps): JSX.Element {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={variant}
    >
      {children}
    </button>
  );
}

// ❌ BAD: React.FC, implicit types
export const Button: React.FC<any> = ({ children, onClick }) => {
  return <button onClick={onClick}>{children}</button>;
};
```

### Async Operations
```typescript
// ✅ GOOD: Explicit Promise type, proper error handling
export async function fetchData(id: string): Promise<Data> {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 25000);

  try {
    const res = await fetch(`/api/data/${id}`, {
      signal: controller.signal,
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
    });

    if (!res.ok) {
      throw new ApiError(res.status, res.statusText);
    }

    return res.json() as Promise<Data>;
  } finally {
    clearTimeout(timeout);
  }
}

// Custom error class with type guard
class ApiError extends Error {
  constructor(public status: number, public statusText: string) {
    super(`API Error: ${status} ${statusText}`);
    this.name = 'ApiError';
  }
}

function isApiError(error: unknown): error is ApiError {
  return error instanceof ApiError;
}
```

## React Best Practices

### Component Guidelines
- **Function components only** (no class components)
- **Focused, single-purpose** (<200 lines)
- **Lift state only when necessary** (start local)
- **Controlled inputs** for forms
- **Proper event types** (`React.ChangeEvent<HTMLInputElement>`, etc.)

### Performance Optimization
**Only optimize when needed**:
```typescript
// Use useMemo for expensive computations
const filteredProducts = useMemo(
  () => products.filter(p => p.rate > minRate),
  [products, minRate]
);

// Use useCallback for callbacks passed to memoized children
const handleClick = useCallback((id: string) => {
  setSelected(id);
}, []);
```

**When to optimize**:
- List rendering >100 items (consider virtualization)
- Heavy computations
- Callbacks passed to `React.memo` components

### State Management Philosophy

**Decision Tree**:
1. **Server state?** → SWR or React Query
2. **Local UI state?** → `useState`
3. **Global UI state?** → Minimal Jotai/Zustand
4. **Prop drilling (>3 levels)?** → Context or state lib

**Example**:
```typescript
// Server state (SWR)
const { data: products, error } = useSWR('/products', fetcher);

// Local state
const [isOpen, setIsOpen] = useState(false);

// Global state (Jotai) - minimal use only
const [toasts, setToasts] = useAtom(toastsAtom);
const [theme, setTheme] = useAtom(themeAtom);
```

## Project-Specific Tech Stack

### Router: wouter (NOT react-router-dom)
**Why**: 8x smaller (1.2KB vs 10KB gzipped)

```typescript
import { Route, Link, useLocation, useRoute } from 'wouter';

// Define routes
<Route path="/" component={HomePage} />
<Route path="/applications/:id" component={Details} />

// Navigation
const [, setLocation] = useLocation();
setLocation('/applications/123');

// Get params
const [match, params] = useRoute('/applications/:id');
if (match) console.log(params.id);

// Links (use href, not to)
<Link href="/applications">Applications</Link>
```

### Data Fetching: SWR (NOT React Query)
**Why**: Lighter, sufficient for CRUD

```typescript
import useSWR from 'swr';
import useSWRMutation from 'swr/mutation';

// GET requests
const { data, error, isLoading } = useSWR('/products', fetcher);

// POST/PUT requests
const { trigger, isMutating } = useSWRMutation(
  '/applications',
  async (url, { arg }: { arg: CreateApplication }) => {
    return fetcher(url, {
      method: 'POST',
      body: JSON.stringify(arg),
    });
  }
);
```

### State: Jotai (Minimal)
**Only use for**:
- Toast notifications
- Theme preference (persisted to localStorage)

```typescript
// atoms/toastsAtom.ts
export const toastsAtom = atom<Toast[]>([]);

// atoms/themeAtom.ts
export const themeAtom = atomWithStorage<Theme>('theme', 'system');

// Usage
const [theme, setTheme] = useAtom(themeAtom);
```

### Styling: CSS Modules + Design Tokens
**No Tailwind, No Material-UI, No component frameworks**

```typescript
// Component
import styles from './Button.module.css';

export function Button({ variant }: Props): JSX.Element {
  return <button className={styles[variant]}>{children}</button>;
}
```

```css
/* Design tokens */
:root {
  --color-primary: #2563eb;
  --spacing-md: 1rem;
  --font-size-lg: 1.125rem;
}

/* Light-dark theming */
:root {
  color-scheme: light dark;
  --color-bg: light-dark(#ffffff, #1a1a1a);
  --color-text: light-dark(#1a1a1a, #e5e5e5);
}
```

### Testing: Vitest + happy-dom
```typescript
import { render, screen } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import userEvent from '@testing-library/user-event';

describe('Component', () => {
  it('handles user interaction', async () => {
    const handleClick = vi.fn();
    const user = userEvent.setup();

    render(<Component onClick={handleClick} />);

    await user.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

**Test Environment**:
- Default: `happy-dom` (2-3x faster than jsdom)
- Available: `jsdom@25.0.1` (via `@vitest-environment jsdom` pragma)

## Forms & Validation

### Custom Hook Pattern
```typescript
// Hook
const { values, errors, touched, handleChange, handleBlur, handleSubmit } =
  useForm({
    initialValues: { email: '', phone: '' },
    validators: {
      email: validateEmail,
      phone: composeValidators(validateRequired, validatePhone),
    },
    onSubmit: async (values) => {
      await createApplication(values);
    },
  });

// Component
<Input
  label="Email"
  value={values.email}
  onChange={handleChange('email')}
  onBlur={handleBlur('email')}
  error={touched.email ? errors.email : undefined}
/>
```

### Validators (Pure Functions)
```typescript
export function validateEmail(value: string): string | undefined {
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
    return 'Invalid email address';
  }
}

export function composeValidators(
  ...validators: Array<(value: string) => string | undefined>
): (value: string) => string | undefined {
  return (value) => {
    for (const validator of validators) {
      const error = validator(value);
      if (error) return error;
    }
  };
}
```

## Error Handling & UX

### Error Boundaries
```typescript
<ErrorBoundary fallback={(error) => <ErrorFallback error={error} />}>
  <App />
</ErrorBoundary>
```

### API Error Handling
```typescript
try {
  await createApplication(data);
  addToast({ type: 'success', message: 'Application created!' });
} catch (error) {
  if (isApiError(error)) {
    addToast({
      type: 'error',
      message: `Failed: ${error.statusText}`
    });
  } else {
    addToast({
      type: 'error',
      message: 'An unexpected error occurred'
    });
  }
}
```

### User Feedback Requirements
- ✅ Toast notifications for actions
- ✅ Loading states for async operations
- ✅ Disabled buttons during submission
- ✅ Actionable error messages
- ✅ Visual save indicators (required by challenge)

## Project Structure

```
src/
  components/      # Shared UI, no business logic
  features/        # Domain-specific with business logic
  hooks/           # Custom React hooks
  utils/           # Pure functions (no side effects)
  services/        # API clients, i18n (side effects)
    i18n/          # Localization files
  atoms/           # Jotai state
  types/           # TypeScript interfaces/types
  styles/          # Global CSS (tokens, reset, base)
```

**Path Aliases**: Use `@/` for cleaner imports
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

## Atomic Commits & Git

### Conventional Commits Format
```
type(scope): description

feat: add product filtering
fix: resolve race condition in form submission
refactor: extract validation logic to utils
test: add coverage for product filters
chore: update dependencies
docs: add API documentation
style: format code with prettier
perf: optimize product list rendering
a11y: improve keyboard navigation
```

### Commit Strategy
- **One logical change per commit** (single file ideal)
- **Grouped only when inseparable** (component + CSS + test)
- **Clear, descriptive messages**
- **Small, focused commits** (easier to review, revert, cherry-pick)

## Pre-commit Automation

### Lefthook (Faster than Husky)
```yaml
# lefthook.yml
pre-commit:
  commands:
    format:
      glob: "*.{ts,tsx,css}"
      run: prettier --write {staged_files}
    lint:
      glob: "*.{ts,tsx}"
      run: eslint {staged_files} --fix
commit-msg:
  commands:
    commitlint:
      run: commitlint --edit
```

**Benefits**: Zero-thought commits, always formatted/linted, enforces standards

## Performance & Bundle Size

### Code Splitting
```typescript
// Route-based splitting
const ProductPage = lazy(() => import('./features/products/ProductPage'));

// Component-based (heavy components only)
const Chart = lazy(() => import('./components/Chart'));

// Usage
<Suspense fallback={<Spinner />}>
  <ProductPage />
</Suspense>
```

### Safe Vendor Chunking Strategy

**CRITICAL**: React + React-DOM must stay together to prevent duplication errors.

```typescript
// vite.config.ts
export default defineConfig({
  resolve: {
    // REQUIRED: Ensure single React instance
    dedupe: ['react', 'react-dom'],
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks(id: string): string | undefined {
          if (!id.includes('node_modules')) return undefined;

          // CRITICAL: Keep React + React-DOM together in ONE chunk
          // They share internal state and MUST NOT be split
          if (id.includes('/react/') || id.includes('/react-dom/')) {
            return 'vendor-react';
          }

          // Safe to include: React hooks utilities
          if (id.includes('use-sync-external-store')) {
            return 'vendor-react';
          }

          // Independent libraries - safe to split by category
          if (id.includes('/wouter/')) return 'vendor-routing';
          if (id.includes('/swr/')) return 'vendor-data';
          if (id.includes('/jotai/')) return 'vendor-state';
          if (id.includes('/i18next/') || id.includes('/react-i18next/')) {
            return 'vendor-i18n';
          }

          // Other utilities
          return 'vendor-lib';
        },
      },
    },
  },
});
```

**Why This Works**:
- React + React-DOM in ONE chunk prevents: `"Cannot set properties of undefined (setting 'Children')"`
- Other libraries are independent and safe to split
- Enables 80%+ cache hit rate on deployments

**Bundle Breakdown Example**:
```
vendor-react   137KB (45KB gz)  ← React + React-DOM (never split!)
vendor-state     9KB  (4KB gz)  ← Jotai (independent)
vendor-data      9KB  (4KB gz)  ← SWR (independent)
vendor-routing   3KB  (2KB gz)  ← wouter (independent)
vendor-i18n      4KB  (2KB gz)  ← i18next (independent)
vendor-lib       5KB  (2KB gz)  ← Utilities
index           11KB  (4KB gz)  ← App code
──────────────────────────────────────
TOTAL          177KB (67KB gz)
```

**Cache Benefits**:
- App code update: Download only 11KB (6% of total)
- React update: Download 148KB (81% of total, vendors cached)
- Vendor update: Download only affected chunk

**Target**: < 400KB gzipped for main bundle

## Accessibility

### Requirements
- ✅ Semantic HTML (`<button>`, `<nav>`, `<main>`, etc.)
- ✅ ARIA labels where needed
- ✅ Keyboard navigation (`tabIndex`, focus management)
- ✅ Focus-visible styles
- ✅ Sufficient color contrast
- ✅ `prefers-reduced-motion` support

### Testing
**Automated** (via Storybook):
- Use `@storybook/addon-a11y` in Storybook
- View "Accessibility" tab for each component
- Tests keyboard nav, ARIA, color contrast

**Manual**:
- Browser DevTools (Lighthouse)
- axe DevTools extension
- Test keyboard-only navigation
- Screen reader testing (VoiceOver, NVDA)

## Deployment

### Vercel Configuration
```json
{
  "buildCommand": "./scripts/build.sh",
  "framework": "vite",
  "outputDirectory": "dist"
}
```

**Environment Variables**: Set via `vercel env add` for production, preview, development

**Auto-deploy**: Enabled on `git push origin master`

## Documentation

### JSDoc for Public APIs
```typescript
/**
 * Fetches user data from the API
 *
 * @param userId - The user's unique identifier
 * @returns Promise resolving to user data
 * @throws {ApiError} If the request fails
 *
 * @example
 * ```ts
 * const user = await fetchUser('123');
 * console.log(user.name);
 * ```
 */
export async function fetchUser(userId: string): Promise<User> {
  // ...
}
```

### Storybook Stories
```typescript
import type { Meta, StoryObj } from '@storybook/react';

const meta = {
  title: 'Components/Button',
  component: Button,
  parameters: {
    layout: 'centered',
  },
  tags: ['autodocs'],
} satisfies Meta<typeof Button>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    variant: 'primary',
    children: 'Click me',
  },
};
```

## Quality Checklist

Before completing work:
- [ ] All tests passing (`npm test`)
- [ ] Build successful (`npm run build`)
- [ ] No linting errors (`npm run lint`)
- [ ] TypeScript strict mode satisfied
- [ ] Accessibility tested (keyboard nav, ARIA)
- [ ] Error states handled
- [ ] Loading states present
- [ ] Responsive design verified
- [ ] Documentation updated (JSDoc, Storybook)
- [ ] Atomic commits with clear messages

## Anti-Patterns

### ❌ Never Use

| Anti-Pattern | Why | Alternative |
|-------------|-----|-------------|
| `any` type | Defeats TypeScript | `unknown` + type guards |
| `React.FC` | Loses generic constraints | Explicit props + return type |
| Inline styles | No scoping, hard to maintain | CSS Modules |
| Tailwind/Material-UI | Against project requirements | CSS Modules + tokens |
| react-router-dom | Too heavy (10KB) | wouter (1.2KB) |
| React Query | Overkill for CRUD | SWR (5KB) |
| Redux/MobX | Too complex | Minimal Jotai |
| `\|\|` operator | Falsy values (0, "") treated as missing | `??` (nullish coalescing) |
| Splitting React/React-DOM | Causes duplication errors | Keep together in ONE chunk |

### ✅ Always Use

| Best Practice | Reason |
|--------------|--------|
| Explicit types and return types | Self-documenting, type-safe |
| CSS Modules with design tokens | Scoped, maintainable styles |
| Atomic, conventional commits | Clear history, easy revert |
| Error boundaries | Graceful error handling |
| Loading and error states | Better UX |
| ARIA + semantic HTML | Accessibility |
| Testing for critical paths | Confidence in deploys |
| JSDoc for public APIs | Documentation |
| `dedupe: ['react', 'react-dom']` | Single React instance |

## Quick Reference

### Component Boilerplate
```typescript
interface Props {
  value: string;
  onChange: (value: string) => void;
}

export function Component({ value, onChange }: Props): JSX.Element {
  return <div>{value}</div>;
}
```

### Test Boilerplate
```typescript
describe('Component', () => {
  it('renders correctly', () => {
    render(<Component value="test" onChange={vi.fn()} />);
    expect(screen.getByText('test')).toBeInTheDocument();
  });
});
```

### API Client
```typescript
export async function fetcher<T>(
  url: string,
  init?: RequestInit
): Promise<T> {
  const response = await fetch(`${API_BASE_URL}${url}`, {
    ...DEFAULT_HEADERS,
    ...init,
  });
  if (!response.ok) {
    throw new ApiError(response.status, response.statusText);
  }
  return response.json() as Promise<T>;
}
```

---

**Philosophy**: Write code for humans first, computers second. Prioritize clarity, maintainability, and type safety over cleverness.
